# React + TypeScript + Vite + Million.js

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type aware lint rules:

- Configure the top-level `parserOptions` property like this:

```js
export default {
  // other rules...
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
    project: ['./tsconfig.json', './tsconfig.node.json'],
    tsconfigRootDir: __dirname,
  },
}
```

- Replace `plugin:@typescript-eslint/recommended` to `plugin:@typescript-eslint/recommended-type-checked` or `plugin:@typescript-eslint/strict-type-checked`
- Optionally add `plugin:@typescript-eslint/stylistic-type-checked`
- Install [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) and add `plugin:react/recommended` & `plugin:react/jsx-runtime` to the `extends` list


## Million.js
Million.js is an extremely fast and lightweight optimizing compiler that make components up to 70% faster.

TL;DR: Imagine React components running at the speed of raw JavaScript.

1. Why Million.js?

To understand why to use Million.js, we need to understand how React updates interfaces. When an application's state or props change, React undergoes an update in two parts: rendering and reconciliation.

To show this, let's say this is our `App`:
```
function App() {
  const [count, setCount] = useState(0);
  const increment = () => setCount(count + 1);
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```
In this `App`, when I click on the button, the `count` state will update and the `<p>` tag will update to reflect the new value. Let's break this down.

2. Rendering

The first step is rendering. Rendering is the process of generating a snapshot of the current component. You can imagine it as simply "calling" the `App` function and storing the output in a variable. This is what the `App` snapshot would look like:

```
const snapshot = App();
 
// snapshot =
<div>
  <p>Count: 1</p>
  <button onClick={increment}>Increment</button>
</div>;
```

3. Reconciliation

In order to update the interface to reflect the new state, React needs to compare the previous snapshot to the new snapshot (called "diffing"). React's reconciler will go to each element in the previous snapshot and compare it to the new snapshot. If the element is the same, it will skip it. If the element is different, it will update it.

- The `<div>` tag is the same, so it doesn't need to be updated. ✅
  + The `<p>` tag is the same, so it doesn't needs to be updated. ✅
    + The text inside the `<p>` tag is different, so it needs to be updated. ⚠ ️
  + The `<button>` tag is the same, so it doesn't need to be updated. ✅
    + The onClick prop is the same, so it doesn't need to be updated. ✅
    + The text inside the `<button>` tag is the same, so it doesn't need to be updated. ✅
(total: 6 diff checks)

```
<div>
-  <p>Count: 0</p>
+  <p>Count: 1</p>
  <button onClick={increment}>Increment</button>
</div>
```

From here, we can see that the `<p>` tag needs to be updated. React will then update the `<p>` DOM node to reflect the new value.

4. How Million.js makes this faster

React is slow.

The issue with React's reconciliation it becomes <b>exponentially slower</b> the more JSX elements you have. With this simple `App`, it only needs to diff a few elements. In a real world React app, you can easily have hundreds of elements, slowing down interface updates.

Million.js solves this by <b>skipping the diffing step entirely</b> and directly updating the DOM node.

Here is a conceptual example of how Million.js reconciler works:
```
function App() {
  const [count, setCount] = useState(0);
  const increment = () => setCount(count + 1);
 
  // generated by compiler
  if (count !== prevCount) {
    <p>.innerHTML = `Count: ${count}`;
  }
 
  <button>.onclick = increment;
 
  // ...
}
```
Notice how when the count is updated, Million.js will directly update the DOM node. Million.js turns React reconciliation from O(n^3) (cubic time) to O(1) (constant time).

How fast is it?
> How fast is it? [→ View the benchmarks](https://breakdance.github.io/breakdance/)  